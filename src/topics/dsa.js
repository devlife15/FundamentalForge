export const DSA = [
  {
    topic: "Arrays vs Linked Lists",
    problem: "When do we need random access vs insertion?",
    concepts: ["time complexity", "memory layout", "cache locality"],
  },
  {
    topic: "Hash Tables",
    problem: "How do we achieve O(1) lookup?",
    concepts: ["hash function", "collision resolution", "load factor"],
  },
  {
    topic: "Stacks",
    problem: "How do we implement LIFO behavior?",
    concepts: ["call stack", "undo/redo", "DFS"],
  },
  {
    topic: "Queues",
    problem: "How do we implement FIFO behavior?",
    concepts: ["BFS", "task scheduling", "circular queue"],
  },
  {
    topic: "Trees (BST)",
    problem: "How do we maintain sorted, searchable data?",
    concepts: ["inorder traversal", "balancing", "O(log n) operations"],
  },
  {
    topic: "Heaps",
    problem: "How do we efficiently get min/max element?",
    concepts: ["priority queue", "heapify", "heap sort"],
  },
  {
    topic: "Graphs",
    problem: "How do we represent relationships?",
    concepts: ["adjacency list/matrix", "directed/undirected", "weighted"],
  },
  {
    topic: "Binary Search",
    problem: "How do we search sorted data efficiently?",
    concepts: ["divide and conquer", "variants", "off-by-one"],
  },
  {
    topic: "DFS vs BFS",
    problem: "When do we explore deep vs wide?",
    concepts: ["stack vs queue", "use cases", "space complexity"],
  },
  {
    topic: "Dynamic Programming",
    problem: "How do we avoid redundant calculations?",
    concepts: ["memoization", "tabulation", "optimal substructure"],
  },
  {
    topic: "Greedy Algorithms",
    problem: "When can we make locally optimal choices?",
    concepts: ["vs DP", "proof of correctness", "common patterns"],
  },
  {
    topic: "Two Pointers",
    problem: "How do we optimize array problems?",
    concepts: ["same direction", "opposite direction", "sliding window"],
  },
  {
    topic: "Sliding Window",
    problem: "How do we track subarrays efficiently?",
    concepts: ["fixed vs variable", "when to use", "time complexity"],
  },
  {
    topic: "Recursion",
    problem: "How do we solve problems by reducing them?",
    concepts: ["base case", "stack overflow", "tail recursion"],
  },
  {
    topic: "Backtracking",
    problem: "How do we explore all solutions?",
    concepts: ["pruning", "state space tree", "common patterns"],
  },
  {
    topic: "Sorting Algorithms",
    problem: "How do we order data efficiently?",
    concepts: ["quicksort/mergesort", "stability", "in-place vs not"],
  },
];
